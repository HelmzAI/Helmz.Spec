syntax = "proto3";

package helmz.v1;

option csharp_namespace = "Helmz.Spec.V1";

import "google/protobuf/timestamp.proto";

// ============================================================================
// Tunnel Protocol — messages that flow INSIDE the E2E encrypted tunnel.
//
// These are NOT gRPC calls. They are protobuf messages serialized, encrypted
// with AES-256-GCM, and sent as opaque bytes through RelayService.Register.
//
// Flow:
//   1. Both sides connect via RelayService.Register
//   2. Key exchange messages flow (plaintext, before encryption is established)
//   3. Once keys are derived, all subsequent Envelope messages are encrypted
//   4. Inside the encrypted envelopes: DaemonService RPC requests/responses
// ============================================================================

// --- Key Exchange (sent before encryption is established) ---

// Key exchange message for X25519 Diffie-Hellman.
// Sent in plaintext as the first tunnel payloads after registration.
// Once both sides have exchanged public keys, they derive a shared
// AES-256-GCM session key and all further communication is encrypted.
message KeyExchange {
  // X25519 public key (32 bytes).
  bytes public_key = 1;
  // Random nonce to prevent replay attacks (32 bytes).
  bytes nonce = 2;
  // Protocol version for forward compatibility.
  uint32 version = 3;
}

// --- Encrypted Envelope (all post-handshake messages) ---

// Encrypted envelope wrapping all application-layer messages.
// The relay sees this as opaque bytes. Only the paired device can decrypt.
message Envelope {
  // AES-256-GCM initialization vector (12 bytes).
  bytes iv = 1;
  // Encrypted + authenticated payload. Contains a serialized Frame.
  bytes ciphertext = 2;
  // AES-256-GCM authentication tag (16 bytes).
  bytes tag = 3;
}

// --- Frame (the decrypted content inside an Envelope) ---

// A decrypted frame carrying one logical message.
// This is what you get after decrypting an Envelope's ciphertext.
message Frame {
  oneof content {
    // Unary RPC request (mobile → daemon).
    RpcRequest rpc_request = 1;
    // Unary RPC response (daemon → mobile).
    RpcResponse rpc_response = 2;
    // Server-streaming chunk (daemon → mobile).
    StreamChunk stream_chunk = 3;
    // Stream completed (daemon → mobile).
    StreamEnd stream_end = 4;
    // Heartbeat / keepalive.
    Heartbeat heartbeat = 5;
  }
  google.protobuf.Timestamp timestamp = 10;
}

// --- RPC over tunnel ---

// A serialized DaemonService RPC request.
// The mobile constructs this, encrypts it, and sends through the tunnel.
message RpcRequest {
  // Unique ID for correlating responses. Generated by the caller.
  string request_id = 1;
  // Fully qualified gRPC method name (e.g. "helmz.v1.DaemonService/StartSession").
  string method = 2;
  // Serialized protobuf request message (e.g. StartSessionRequest bytes).
  bytes payload = 3;
}

// A serialized DaemonService RPC response.
// The daemon constructs this after executing the request locally.
message RpcResponse {
  // Matches the request_id from the original RpcRequest.
  string request_id = 1;
  // Serialized protobuf response message (e.g. StartSessionResponse bytes).
  // Empty if error is set.
  bytes payload = 2;
  // Error information if the RPC failed.
  RpcError error = 3;
}

message RpcError {
  // gRPC-style status code.
  int32 code = 1;
  // Human-readable error message.
  string message = 2;
}

// --- Server-streaming over tunnel ---

// A chunk from a server-streaming RPC (e.g. StreamOutput, StreamActions).
// The daemon sends these continuously after the mobile opens a stream.
message StreamChunk {
  // Matches the request_id that initiated the stream.
  string request_id = 1;
  // Serialized protobuf message for this chunk (e.g. OutputChunk bytes).
  bytes payload = 2;
  // Sequence number within this stream for ordering.
  uint64 sequence = 3;
}

// Signals that a server stream has ended.
message StreamEnd {
  // Matches the request_id that initiated the stream.
  string request_id = 1;
  // If the stream ended due to an error.
  RpcError error = 2;
}

// --- Keepalive ---

message Heartbeat {}
